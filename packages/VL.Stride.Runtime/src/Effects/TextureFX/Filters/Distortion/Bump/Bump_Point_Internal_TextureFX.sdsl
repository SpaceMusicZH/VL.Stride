// source:
// https://github.com/mrvux/dx11-vvvv-girlpower/blob/master/nodes/texture11/Filter/Bump.tfx

shader Bump_Point_Internal_TextureFX : BumpBase
{
    float4 PhongPoint(float3 PosW, float3 NormV, float3 ViewDirV, float3 LightDirV)
    {
        float d = distance(PosW, lDir);
        float atten = 0;

        //compute attenuation only if vertex within lightrange
        if (d<lRange)
        {
            atten = 1/(saturate(lAtt0) + saturate(lAtt1) * d + saturate(lAtt2) * pow(d, 2));
        }

        float4 amb = lAmb * atten;
        amb.a = 1;

        //halfvector
        float3 H = normalize(ViewDirV + LightDirV);

        //compute blinn lighting
        float4 shades = lit(dot(NormV, LightDirV), dot(NormV, H), lPower);

        float4 diff = lDiff * shades.y * atten;
        diff.a = 1;

        //reflection vector (view space)
        float3 R = normalize(2 * dot(NormV, LightDirV) * NormV - LightDirV);

        //normalized view direction (view space)
        float3 V = normalize(ViewDirV);

        //calculate specular light
        float4 spec = pow(max(dot(R, V), 0), lPower*.2) * lSpec;

        return ((amb + diff) + spec)*smoothstep(1, 1-max(0, SmoothSpot)*0.99999, d/lRange);
    }


    float3 Bump(float4 nmap, float2 uv, float2 R)
    {
        float3 NormV = float3(nmap.x  -0.5, -(nmap.y  -0.5), -1);

        NormV = lerp (float3(0, 0, -1), NormV, BumpAmount);
        NormV = normalize(NormV);
        float3 ViewDirV = -normalize(float3((uv.xy * 2 - 1) * float2(1, -1) * R/R.x, 1));

        float3 PosW = float3((uv.xy * 2 - 1) * float2(1, -1) * R/R.x * 0.5, 0);
        float3 LightDirV = normalize(lDir - PosW);

        return PhongPoint(PosW, NormV, ViewDirV, LightDirV).rgb;
    };
};